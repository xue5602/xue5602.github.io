<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xue5602.github.io/"/>
  <updated>2019-03-08T08:50:51.652Z</updated>
  <id>https://xue5602.github.io/</id>
  
  <author>
    <name>tina</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular Js 双向数据绑定原理</title>
    <link href="https://xue5602.github.io/2019/03/08/Angular%20Js%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://xue5602.github.io/2019/03/08/Angular Js 双向数据绑定原理/</id>
    <published>2019-03-08T08:11:24.000Z</published>
    <updated>2019-03-08T08:50:51.652Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><blockquote><p>近期接手了公司的一个老项目，需要在原有项目的基础上做些改进。由于之前没用过angularjs,在刚开始的时候非常痛苦，在改代码的过程中需要一个一个指令的查。到了后期，虽然不需要一个一个指令的查，但对于angularjs也只是一知半解。比如下面这一段代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$scope.safeApply = function(fn)&#123;</span><br><span class="line">   var phase = this.$root.$$phase;</span><br><span class="line">   if (phase == &apos;$apply&apos; || phase == &apos;$digest&apos;) &#123;</span><br><span class="line">       if (fn &amp;&amp; ( typeof (fn) === &apos;function&apos;)) &#123;</span><br><span class="line">          fn();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       this.$apply(fn);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码看，它对的意思应该是，当phase满足以上条件的时候执行fn这个函数，否则执行scope.$apply(fn)。</p><h5 id="对于这段代码，我有几个疑问"><a href="#对于这段代码，我有几个疑问" class="headerlink" title="对于这段代码，我有几个疑问"></a>对于这段代码，我有几个疑问</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. $$phase 是什么？</span><br><span class="line">2. $apply的作用是什么？</span><br></pre></td></tr></table></figure><p>对于第一个问题，简单的做一些描述，$$phase 是 angluar 内部使用的<font color="red">状态标志位，用于标识当前是否处于 digest 状态。</font></p><p>对于第二个问题，$apply的作用是什么？这个就涉及到angularjs的双向数据绑定的特性，现下做一个详细的探索。</p><blockquote><p>双向数据绑定意味着，当视图(view)中的数据发生变化的时候，作用域下的数据模型(model)也会相应的更新。同样的，当数据模型(model)发生变化的时候，视图(view)也会相应的更新。那么，AngularJS是怎么做到的呢？当你写这样的一个表达式的时候( )，AngularJS在背后为这个数据模型(model)设置了一个监听器(watcher)，正是由于这个监听器(watcher)，无论何时当数据模型(model)发生变化的时候，视图(view)也会更新。</p></blockquote><p>$watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$watch(&apos;aModel&apos;, function(newValue, oldValue) &#123;</span><br><span class="line">  //update the DOM with newValue</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>传入到$watch()中的第二个参数是一个回调函数，该函数在aModel的值发生变化的时候会被调用。当aModel发生变化的时候，这个回调函数会被调用来更新view这一点不难理解，但是，还存在一个很重要的问题！AngularJS是如何知道什么时候要调用这个回调函数呢？换句话说，AngularJS是如何知晓aModel发生了变化，才调用了对应的回调函数呢？它会周期性的运行一个函数来检查scope模型中的数据是否发生了变化吗？好吧，这就是$digest循环的用武之地了。</p><p>在$digest循环中，watchers会被触发。当一个watcher被触发时，AngularJS会检测scope模型，如果它发生了变化那么关联到该watcher的回调函数就会被调用。那么，下一个问题就是$digest循环是在什么时候以各种方式开始的？</p><p>在调用了$scope.$digest()后，$digest循环就开始了。假设你在一个ng-click指令对应的handler函数中更改了scope中的一条数据，此时AngularJS会自动地通过调用$digest()来触发一轮$digest循环。当$digest循环开始后，它会触发每个watcher。这些watchers会检查scope中的当前model值是否和上一次计算得到的model值不同。如果不同，那么对应的回调函数会被执行。调用该函数的结果，就是view中的表达式内容(译注：诸如)会被更新。除了ng-click指令，还有一些其它的built-in指令以及服务来让你更改models(比如ng-model，$timeout等)和自动触发一次$digest循环。</p><p>但是，又一个小问题，实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;uidSelect&quot; class=&quot;sel&quot; ng-model=&quot;sid&quot; ng-init=&quot;&quot; ng-options=&quot;user.name for user in users&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;&quot; default&gt;-Select one-&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>因为开始的时候users数组的数据是固定的浏览器渲染出来后值就是固定的,那么如果在这之后我们想往users里面添加数据这个下拉选项是不会有改变的。此时，我们可以通过调用 scope.$apply()实时刷新ui。</p><h5 id="apply-方法的两种形式"><a href="#apply-方法的两种形式" class="headerlink" title="$apply() 方法的两种形式"></a>$apply() 方法的两种形式</h5><p>1） 无参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.bind(&apos;click&apos;, function() &#123;</span><br><span class="line">  scope.foo++;</span><br><span class="line">  //if error</span><br><span class="line">  scope.$apply();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>弊端：当我们使用这种形式的时候，如果在scope.$apply之前程序发生异常，那scope.$apply没有执行，界面就不会更新</p><p>2）有参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.bind(&apos;click&apos;, function() &#123;</span><br><span class="line">  scope.$apply(function() &#123;</span><br><span class="line">      scope.foo++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)               // 即使后面发生异常，数据还是会实时更新</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>只有在$scope变量绑定到页面上，才会创建 $watch</li><li>$apply决定事件是否可以进入angular context</li><li>$digest 循环检查model时最少两次，最多10次(多于10次抛出异常，防止无限检查)</li><li>AngularJs自带的指令已经实现了$apply，所以不需要我们额外的编写</li><li>在自定义指令时，建议使用带function参数的$apply</li></ol><p><font color="blue">参考文献</font></p><ul><li><a href="https://www.jianshu.com/p/ad0c48810bf1" target="_blank" rel="noopener">https://www.jianshu.com/p/ad0c48810bf1</a></li><li><a href="https://blog.csdn.net/dm_vincent/article/details/38705099" target="_blank" rel="noopener">https://blog.csdn.net/dm_vincent/article/details/38705099</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;近期接手了公司的一个老项目，需要在原有项目的基础上做些改进。由于之前没用过angularjs,在刚开始的时候非常痛苦，在改代码的过程
      
    
    </summary>
    
      <category term="Angular" scheme="https://xue5602.github.io/categories/Angular/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟dom和diff算法</title>
    <link href="https://xue5602.github.io/2019/02/20/%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
    <id>https://xue5602.github.io/2019/02/20/虚拟dom和diff算法/</id>
    <published>2019-02-20T08:17:23.000Z</published>
    <updated>2019-02-20T09:00:18.801Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><ul><li><a href="https://juejin.im/post/5c4a76b4e51d4526e57da225" target="_blank" rel="noopener">虚拟DOM和Diff算法 - 入门级</a></li><li><a href="https://segmentfault.com/a/1190000016723305" target="_blank" rel="noopener">虚拟dom与diff算法</a></li></ul><h5 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h5><blockquote><p>一个虚拟dom其实质是一个js对象，用来保存真实DOM的层次关系和一些基本属性。</p></blockquote><p>传统的DOM结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;item1&quot;&gt; first &lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item2&quot;&gt; second &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>相对应的可以表现为如下形式(虚拟DOM)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: &apos;ul&apos;,</span><br><span class="line">    attr: &#123;</span><br><span class="line">        id: list</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: &apos;li&apos;,</span><br><span class="line">            attr: &#123;</span><br><span class="line">                className: &apos;item1&apos;,</span><br><span class="line">            &#125;</span><br><span class="line">            children: [</span><br><span class="line">            &apos;first&apos;]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            tag: &apos;li&apos;,</span><br><span class="line">            attr: &#123;</span><br><span class="line">                className: &apos;item2&apos;,</span><br><span class="line">            &#125;</span><br><span class="line">            children: [</span><br><span class="line">            &apos;second&apos;]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="什么要使用虚拟的DOM？"><a href="#什么要使用虚拟的DOM？" class="headerlink" title="什么要使用虚拟的DOM？"></a>什么要使用虚拟的DOM？</h5><blockquote><p>将DOM抽象为虚拟的DOM，通过对比新旧两个虚拟DOM的差异(Diff算法)，从而只把变化的部分重新渲染，提高渲染效率。</p></blockquote><h5 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h5><p><font color="red">diff算法的实现流程如下：</font></p><p><img src="https://image-static.segmentfault.com/321/760/321760932-5707797107835" alt="image"></p><p><font color="red">react diff 算法（tree diff）</font></p><p><img src="https://image-static.segmentfault.com/277/884/2778846299-5707849bd3992" alt="image"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5c4a76b4e51d4526e57da225&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="web" scheme="https://xue5602.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>git flow</title>
    <link href="https://xue5602.github.io/2019/02/02/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8git%20flow/"/>
    <id>https://xue5602.github.io/2019/02/02/如何正确使用git flow/</id>
    <published>2019-02-02T08:10:48.000Z</published>
    <updated>2019-02-03T00:58:36.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><blockquote><p>在开发一个项目的时候，总是会遇到版本回退和版本客制化的问题，糟糕的分支管理会使整个开发过程痛苦不堪。版本管理的挑战：</p><ol><li>如何开发一个Feature分支，又不影响其他的Feature分支？</li><li>分支多了如何管理，时间就了每个分支是干什么的？</li><li>哪些分支已经合并并回了主干？</li><li>如何进行Release分支的管理？开始一个Release的时候如何冻结Feature，如何在Prepare Release 的时候，开发人员可以继续新功能的开发？</li><li>线上代码除bug了，如何快速修复？而且修复的代码包含到开发人员的分支以及下一个Release？</li></ol></blockquote><hr><h4 id="下面介绍一种常见的工作流程-git-flow"><a href="#下面介绍一种常见的工作流程-git-flow" class="headerlink" title="下面介绍一种常见的工作流程 git flow"></a>下面介绍一种常见的工作流程 <font color="red">git flow</font></h4><blockquote><p>git flow 的特色在于为不同的分支分配明确的角色，并定义了使用场景和用法。</p></blockquote><h5 id="git-flow-常用的分支"><a href="#git-flow-常用的分支" class="headerlink" title="git flow 常用的分支"></a>git flow 常用的分支</h5><ul><li>Master 分支<br>这个分支显示的是最近发布到生产环境的代码，最近发布的Release, 该分支只能从其他分支合并代码，不能在这个分支直接修改代码</li><li>Develop 分支<br>这个分支是我们的主开发分支，包含所有发布到一下个Release代码</li><li>Feature 分支<br>这个分支主要用来开发一个新的功能，一旦开发完成，我们会合并到Develop分支进行下一个Release</li><li>Release 分支<br>当需要发布一个新的Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，将其合并到Master和Develop分支</li><li><p>Hotfix 分支<br>当发现产线上出来一个bug后，我们需要创建一个Hotfix分支完成bug修复，测试完成后，将该分支合并到Master和Develop分支，所以Hotfix的改动会进入下一个Release</p><h5 id="git-flow-操作实践"><a href="#git-flow-操作实践" class="headerlink" title="git flow 操作实践"></a>git flow 操作实践</h5><p>第一步： 创建一个develop分支，并把它推到服务器</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><p>develop 分支将包含项目的所有历史。开发者可以clone中央仓库，并为develop分支创建一个追踪分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://......</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure><p>第二步： 创建Feature分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b Featurename develop</span><br><span class="line">git push -u origin Featurename</span><br></pre></td></tr></table></figure><p>注意： Feature 的父分支应该选择develop</p><p>第三步： Feature分支的功能开发完成后(edit 、state、commit)，将其合并到develop分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop     //确保develop分支拥有最新代码</span><br><span class="line">git checkout develop</span><br><span class="line">git merge Featurename</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>注意：新开发的功能代码永远不能直接合并到master分支。</p><p>第四步：创建Release分支，做产品发布准备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release develop</span><br><span class="line">git push -u origin release</span><br></pre></td></tr></table></figure><p>这个分支专门用于发布前准备，包括一些清理工具、全面测试、文档的更新及准备工作。</p><p>第五步：测试通过后，就可以将Release分支上的内容合并到master和develop分支上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge release</span><br><span class="line">git push</span><br><span class="line">git checkout develop</span><br><span class="line">git merge release</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>注意： Release保持最新版本的代码，该分支扮演着开发和生产之间的一个缓冲。无论什么时候把一些东西合并到master分支，都需要打一个tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0.0 -m &quot;版本v1.0.0&quot; master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>第六步： 当产品线出现bug后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hotfix master</span><br></pre></td></tr></table></figure><p>第七步：完成bug修复后，并通过测试，将hotfix分支上的内容合并到master/develop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line">git push</span><br><span class="line">git checkout develop</span><br><span class="line">git merge hotfix</span><br><span class="line">git push</span><br><span class="line">git branch - d hotfix</span><br></pre></td></tr></table></figure><p>第八步： 基于master分支，打tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0.0/fix  master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h5 id="git-flow-工具"><a href="#git-flow-工具" class="headerlink" title="git flow 工具"></a>git flow 工具</h5><ol><li>安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-flow</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p>这个命令会进行一些默认的配置，自动创建master、develop、feature、release、hotfix分支。当进行新功能开发的时候，可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start Featurename</span><br></pre></td></tr></table></figure><p>完成开发后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish Featurename</span><br></pre></td></tr></table></figure><p>该命令会将feature/Featurename 合并到develop分支，并删除feature分支。</p><ol start="3"><li>当功能点都完成后，基于develop分支创建一个release分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow release start v1.0.0</span><br><span class="line">git flow release finish v1.0.0</span><br></pre></td></tr></table></figure><p>注：当完成（finish)一个发布分支时，它会把release分支上的内容合并到master分支，同时合并回develop分支，打tag。之后我们只需要把master和tag都推到远程仓库就行。</p><ol start="4"><li>当产线出现bug，需要紧急修复时。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start v1.0.0</span><br></pre></td></tr></table></figure><p>完成bug修复后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish v1.0.0</span><br></pre></td></tr></table></figure><p>注：当完成（finish)一个修复分支时，它会把hotfix分支上的内容合并到master分支，同时合并回develop分支。</p><p>参考：<a href="https://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnblogsfans/p/5075073.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;在开发一个项目的时候，总是会遇到版本回退和版本客制化的问题，糟糕的分支管理会使整个开发过程痛苦不堪。版本管理的挑战：&lt;/p&gt;&lt;ol&gt;
      
    
    </summary>
    
      <category term="git" scheme="https://xue5602.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>git 常用命令</title>
    <link href="https://xue5602.github.io/2019/02/02/git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://xue5602.github.io/2019/02/02/git 常用命令/</id>
    <published>2019-02-02T05:10:24.000Z</published>
    <updated>2019-02-03T00:58:52.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. git branch -a  查看远程分支</span><br><span class="line">2. git push origin --delete &lt;branchName&gt;  删除远程分支</span><br><span class="line">3. git push origin :&lt;branchName&gt; 删除远程分支</span><br><span class="line">4. git push origin --delete tag &lt;tagname&gt;  删除远程tag</span><br><span class="line">5. git push origin :refs/tags/&lt;tagname&gt;   删除远程tag</span><br><span class="line">6. git fetch -p   删除没有与远程分支对应的本地分支</span><br><span class="line">7. 重命名远程分支</span><br><span class="line">  git push --delete origin branchname</span><br><span class="line">  git branch -m branchname newname  //重命名本地分支</span><br><span class="line">  git push origin newname</span><br><span class="line">8. git fetch origin tag &lt;tagname&gt;   获取远程tag</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/human/p/5128482.html" target="_blank" rel="noopener">git 撤销&amp;回滚操作</a></p><p>应用场景</p><blockquote><p>1、把不想要的代码commit到本地仓库，但是还没有push操作；<br>2、push上去的代码有问题，需要还原上一次提交</p></blockquote><p>场景1 撤销修改<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git reset HEAD fileName</span><br><span class="line">git checkout fileName</span><br></pre></td></tr></table></figure><p></p><p>场景2 回滚 （首先确保当前工作区是干净的，并且和远程分支代码一致 ）<br>撤销指定文件到指定版本<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;filename&gt;</span><br><span class="line">git checkout &lt;commitID&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><p></p><p>删除最后一次提交<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure><p></p><p>回滚某次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline -n5</span><br><span class="line">git rebase -i &quot;commit id&quot;^</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/xxooff/article/details/79423767" target="_blank" rel="noopener">git 解决冲突</a></p><p>git push 时产生冲突<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull          </span><br><span class="line">git push    //git 自动合并冲突</span><br></pre></td></tr></table></figure><p></p><p>如果在git pull 时就存在冲突<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方法一  丢弃本地修改，采用远程文件覆盖本地文件</span><br><span class="line"></span><br><span class="line">        git checkout [文件路径]</span><br><span class="line">        </span><br><span class="line">方法二  手动解决冲突，找到冲突文件中下列标示</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和=======中间的是你自己的代码，  =======  和&gt;&gt;&gt;&gt;&gt;&gt;&gt;中间的是其他人修改的代码。</span><br><span class="line"></span><br><span class="line">确保自己要保留的代码，并删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，=======  ，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标示</span><br><span class="line"></span><br><span class="line">方法三  暂存本地修改</span><br><span class="line"></span><br><span class="line">        git stash     //将本地修改暂存到工作区</span><br><span class="line">        git pull       </span><br><span class="line">        git stash pop  //从栈中将本地修改的代码提取出来</span><br></pre></td></tr></table></figure><p></p><p><a href="https://blog.csdn.net/wh_19910525/article/details/7784901" target="_blank" rel="noopener">git stash 详解</a></p><p>git stash 可以暂存当前正在进行的工作， 比如想pull最新代码，又不想新加commit；还有一种情况就是，为了fix一个紧急的bug，需要回到上一个commit，</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="git" scheme="https://xue5602.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>css隐藏滚动条</title>
    <link href="https://xue5602.github.io/2019/01/26/css%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <id>https://xue5602.github.io/2019/01/26/css隐藏滚动条/</id>
    <published>2019-01-26T10:29:38.000Z</published>
    <updated>2019-01-31T09:09:22.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><blockquote><p>导语： 在前端开发中，我们经常会遇到这样的情况，为了让页面看起来更加美观，需要将滚动条进行隐藏。下面介绍几种常用的方法：</p></blockquote><p>方法1、 使用三个容器将内容包裹起来，并通过css样式将滚动条隐藏<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outer-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner-container&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">           ......</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.outer-container &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner-container &#123;</span><br><span class="line">  height: calc(100% - 40px);</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  overflow-y: scroll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner-container::-webkit-scrollbar &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意</font></p><blockquote><p>::-webkit-scrollbar 仅仅支持webkit的浏览器，如Chrome，Safari等</p></blockquote><p>方法2、外层容器的宽度设置为窗口宽度 + 10px<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.outer-container &#123;</span><br><span class="line">  width: calc(100vw + 10px);   // 隐藏滚动条</span><br><span class="line">&#125;</span><br><span class="line">.inner-container &#123;</span><br><span class="line">  height: calc(100% - 40px);</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  overflow-y: scroll;</span><br><span class="line">&#125;</span><br><span class="line">.inner-container::-webkit-scrollbar &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;导语： 在前端开发中，我们经常会遇到这样的情况，为了让页面看起来更加美观，需要将滚动条进行隐藏。下面介绍几种常用的方法：&lt;/p&gt;&lt;/
      
    
    </summary>
    
      <category term="web" scheme="https://xue5602.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>angular-translate进行项目国际化</title>
    <link href="https://xue5602.github.io/2019/01/19/angular-translate%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>https://xue5602.github.io/2019/01/19/angular-translate进行项目国际化/</id>
    <published>2019-01-19T03:17:23.000Z</published>
    <updated>2019-03-08T08:50:45.305Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><ol><li>安装插件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bower install angular-translate </span><br><span class="line">bower install angular-translate-loader-static-files</span><br></pre></td></tr></table></figure><ol start="2"><li>直接引入（二选一）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;editor-app/libs/angular-translate_2.4.2/angular-translate.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;editor-app/libs/angular-translate-loader-static-files/angular-translate-loader-static-files.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>注： angular-translate-loader-static-files.min.js用来读取本地多语言文件。</p><ol start="3"><li>添加翻译文本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目中建立/i18/文件夹，然后在该文件夹中添加对应的json文件（en-us.json/ch-cn.json）</span><br></pre></td></tr></table></figure><p>4.注入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var myApp = angular.module(&apos;myApp&apos;, [</span><br><span class="line">  &apos;pascalprecht.translate&apos;]);</span><br><span class="line"></span><br><span class="line">myApp.config([&apos;$translateProvider&apos;, function ( $translateProvider) &#123;</span><br><span class="line"></span><br><span class="line"> // 从cookie里获取 lang</span><br><span class="line">    function getCookie(name)&#123;</span><br><span class="line">        var strcookie = document.cookie;//获取cookie字符串</span><br><span class="line">        var arrcookie = strcookie.split(&quot;; &quot;);//分割</span><br><span class="line">        for ( var i = 0; i &lt; arrcookie.length; i++) &#123;</span><br><span class="line">            var arr = arrcookie[i].split(&quot;=&quot;);</span><br><span class="line">            if (arr[0] == name)&#123;</span><br><span class="line">                return arr[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var lang = getCookie(&apos;language&apos;);</span><br><span class="line">    </span><br><span class="line">    $translateProvider.useStaticFilesLoader(&#123;</span><br><span class="line">        prefix: &apos;/i18n/&apos;,</span><br><span class="line">        suffix: &apos;.json&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">        // 加载本地多语言配置文件</span><br><span class="line">        $translateProvider.useStaticFilesLoader(&#123;</span><br><span class="line">            prefix: &apos;./i18n/&apos;,</span><br><span class="line">            suffix: &apos;.json&apos;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    $translateProvider.preferredLanguage(lang);</span><br></pre></td></tr></table></figure><ol start="5"><li>创建过滤器做html内容国际化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.filter(&apos;translate&apos;, [&apos;$translate&apos;, function ($translate) &#123;</span><br><span class="line">    return function (key) &#123;</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        return $translate.instant(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div </span><br><span class="line">    class=&quot;Or-button&quot; </span><br><span class="line">id=&quot;delete-button&quot; </span><br><span class="line">title=&quot;&#123;&#123;&apos;BUTTON.DELETE.TOOLTIP&apos; | translate&#125;&#125;&quot;</span><br><span class="line">ng-click=&quot;deleteTooltip()&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>javascript 脚本中使用国际化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$translate.instant(&quot;TOOLBAR.DESIGN.MODULE&quot;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;ol&gt;&lt;li&gt;安装插件&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="Angular" scheme="https://xue5602.github.io/categories/Angular/"/>
    
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="https://xue5602.github.io/2019/01/12/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://xue5602.github.io/2019/01/12/原型链/</id>
    <published>2019-01-12T07:24:05.000Z</published>
    <updated>2019-01-31T09:07:36.295Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote><p>a. 构造函数的首字母大写 (习惯)<br>b. 内部使用this对象，指向即将生成的实例对象<br>c. 使用new来生成实例对象</p></blockquote><p>new 一个对象<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    this.p = “I’m in constructed object”;</span><br><span class="line">    this.alertP = function()&#123;</span><br><span class="line">        alert(this.p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var o2 = new Person();</span><br></pre></td></tr></table></figure><p></p><p>new操作符来调用一个函数，发生了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj._ptoto_ = Person.prototype;</span><br><span class="line">Person.call(obj);</span><br><span class="line">return obj</span><br></pre></td></tr></table></figure><p><font color="red">prototype属性 <font></font></font></p><p>每一个构造函数都有一个属性：prototype，其作用是为一个特定类申明通用的变量和函数。<br>在函数内定义的变量和函数如果不对外提供接口，外部将无法访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Obj()&#123;</span><br><span class="line">                var a=0; //私有变量</span><br><span class="line">                var fn=function()&#123; //私有函数</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o=new Obj();</span><br><span class="line">console.log(o.a); //undefined</span><br><span class="line">console.log(o.fn); //undefined</span><br></pre></td></tr></table></figure><p>静态变量、函数<br>当定义一个函数后，通过.添加的属性和函数，通过对象本身是可以访问，但实例却不可以访问，这样的变量和函数称为静态变量和静态函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Obj()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.a=0; //静态变量</span><br><span class="line"></span><br><span class="line">Obj.fn=function()&#123; //静态函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Obj.a); //0</span><br><span class="line">console.log(typeof Obj.fn); //function</span><br><span class="line"></span><br><span class="line">var o=new Obj();</span><br><span class="line">console.log(o.a); //undefined</span><br><span class="line">console.log(typeof o.fn); //undefined</span><br></pre></td></tr></table></figure><p>实例变量和函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Obj()&#123;</span><br><span class="line">    this.a=[]; //实例变量</span><br><span class="line">    this.fn=function()&#123; </span><br><span class="line">        //实例方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(typeof Obj.a); //undefined</span><br><span class="line">console.log(typeof Obj.fn); //undefined</span><br><span class="line"></span><br><span class="line">var o=new Obj();</span><br><span class="line">console.log(typeof o.a); //object</span><br><span class="line">console.log(typeof o.fn); //function</span><br></pre></td></tr></table></figure><p>一个函数要作为一个真正意义上的构造函数，必须满足下列条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在函数内部对新对象（this）的属性进行设置，通常是添加属性和方法。</span><br><span class="line">构造函数可以包含返回语句（不推荐），但返回值必须是this，或者其它非对象类型的值。</span><br></pre></td></tr></table></figure><h4 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h4><blockquote><p>所有引用类型（函数，数组，对象）都拥有<strong>proto</strong>属性（隐式原型）<br>所有函数拥有prototype属性（显式原型）（仅限函数）<br>原型对象：拥有prototype属性的对象，在定义函数时就被创建<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创建构造函数</span><br><span class="line">function Word(words)&#123;</span><br><span class="line">    this.words = words;</span><br><span class="line">&#125;</span><br><span class="line">Word.prototype = &#123;</span><br><span class="line">    alert()&#123;</span><br><span class="line">        alert(this.words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建实例</span><br><span class="line">var w = new Word(&quot;hello world&quot;);</span><br><span class="line">w.print = function()&#123;</span><br><span class="line">    console.log(this.words);</span><br><span class="line">    console.log(this);  //Person对象</span><br><span class="line">&#125;</span><br><span class="line">w.print();  //hello world</span><br><span class="line">w.alert();  //hello world</span><br></pre></td></tr></table></figure><p></p></blockquote><p>实例w的隐式原型指向它构造函数的显式原型，指向的意思是恒等于<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.__proto__ === Word.prototype</span><br></pre></td></tr></table></figure><p></p><p>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的<strong>proto</strong>属性中调用查找，也就是它构造函数的prototype中调用查找。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.a = &quot;a&quot;;</span><br><span class="line">Object.prototype.b = &quot;b&quot;;</span><br><span class="line">function Person()&#123;&#125;</span><br><span class="line">console.log(Person);    //function Person()</span><br><span class="line">let p = new Person();</span><br><span class="line">console.log(p);         //Person &#123;&#125; 对象</span><br><span class="line">console.log(p.a);       //undefined</span><br><span class="line">console.log(p.b);       //b</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Function()&#123;&#125;</span><br><span class="line">console.log(Function); // Function()</span><br><span class="line">console.log(Function.prototype.constructor);    //Function()</span><br><span class="line">console.log(Function.prototype.__proto__);      //Object.prototype</span><br><span class="line">console.log(Function.prototype.__proto__.__proto__);    //NULL</span><br><span class="line">console.log(Function.prototype.__proto__.constructor);  //Object()</span><br><span class="line">console.log(Function.prototype.__proto__ === Object.prototype); //true</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;h4 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h4&gt;&lt;block
      
    
    </summary>
    
      <category term="web" scheme="https://xue5602.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript继承</title>
    <link href="https://xue5602.github.io/2019/01/05/javascript%E7%BB%A7%E6%89%BF/"/>
    <id>https://xue5602.github.io/2019/01/05/javascript继承/</id>
    <published>2019-01-05T02:15:50.000Z</published>
    <updated>2019-01-10T02:17:24.631Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><h4 id="继承分类"><a href="#继承分类" class="headerlink" title="继承分类"></a>继承分类</h4><p><img src="https://image-static.segmentfault.com/136/122/1361227592-5b550040b1c6c" alt="image"></p><ol><li>基于原型链继承（把子类的prototype设置为父类的实例）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 继承</span><br><span class="line">Student.prototype = new Person()</span><br></pre></td></tr></table></figure></li></ol><p>原型继承的缺点：如果属性是引用类型的话，会共享引用类型(<font color="red">引用属性会被所有实例共享</font>)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Person() &#123;</span><br><span class="line">  this.hobbies = [&apos;music&apos;,&apos;reading&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 继承</span><br><span class="line">Student.prototype = new Person()</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stu1 = new Student()</span><br><span class="line">var stu2 = new Student()</span><br><span class="line"></span><br><span class="line">stu1.hobbies.push(&apos;basketball&apos;)</span><br><span class="line"></span><br><span class="line">console.log(stu1.hobbies)   // music,reading,basketball</span><br><span class="line">console.log(stu2.hobbies)   // music,reading,basketball</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数继承（在子类中执行父类的构造函数）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Person() &#123;</span><br><span class="line">  this.hobbies = [&apos;muisc&apos;, &apos;writing&apos;, &apos;reading&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Student()&#123;</span><br><span class="line">    Person.call(this)      // 改动的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stu1 = new Student()</span><br><span class="line">var stu2 = new Student()</span><br><span class="line">stud1.hobbies.push(&apos;swimming&apos;)</span><br><span class="line">console.log(stud1.hobbies) // [&apos;muisc&apos;, &apos;writing&apos;, &apos;reading&apos;, &apos;swimming&apos;]</span><br><span class="line">console.log(stud2.hobbies) // [&apos;muisc&apos;, &apos;writing&apos;, &apos;reading&apos;]</span><br></pre></td></tr></table></figure><p>构造函数解决了引用类型被共享的问题，但是同时也导致了一个新的问题，每实例化一个子类，就复制了一次父类。</p><table><thead><tr><th>继承方式</th><th>继承核心代码</th><th>优缺点</th></tr></thead><tbody><tr><td>原型链继承</td><td><font color="red">Student.prototype = new Person()</font></td><td>实例的引用类型共享</td></tr><tr><td>构造函数继承</td><td><font color="red">在子类(Student)里执行 Person.call(this)</font></td><td>实例的引用类型不共享</td></tr></tbody></table><ol start="3"><li>组合继承（普通函数使用构造函数继承，函数使用原型链继承）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Person() &#123;</span><br><span class="line">  this.hobbies = [&apos;music&apos;,&apos;reading&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类函数</span><br><span class="line">Person.prototype.say = function() &#123;console.log(&apos;I am a person&apos;)&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Student()&#123;</span><br><span class="line">    Person.call(this)             // 构造函数继承(继承属性) （第二次调用）</span><br><span class="line">&#125;</span><br><span class="line">// 继承</span><br><span class="line">Student.prototype = new Person()  // 原型链继承(继承方法) (第一次调用)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 实例化</span><br><span class="line">var stu1 = new Student()</span><br><span class="line">var stu2 = new Student()</span><br><span class="line"></span><br><span class="line">stu1.hobbies.push(&apos;basketball&apos;)</span><br><span class="line">console.log(stu1.hobbies)           // music,reading,basketball</span><br><span class="line">console.log(stu2.hobbies)           // music,reading</span><br><span class="line"></span><br><span class="line">console.log(stu1.say == stu2.say)   // true</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>父类的方法可以被复用</li><li>父类的引用属性不会被共享</li><li>子类构建实例时可以向父类传递参数</li></ul><p>缺点：</p><ul><li>调用了两次父类的构造函数，第二次调用覆盖了第一次调用的同名参数。这种被覆盖的情况造成了性能上的浪费。</li></ul><ol start="4"><li>寄生式继承<br>核心：使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123; </span><br><span class="line">    var clone=object(original);    //通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi = function()&#123;      //以某种方式来增强这个对象</span><br><span class="line">        alert(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;                  //返回这个对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); //&quot;hi&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>寄生组合继承</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123;</span><br><span class="line">    var prototype = object(superType.prototype); // 创建了父类原型的浅复制</span><br><span class="line">    prototype.constructor = subType;             // 修正原型的构造函数</span><br><span class="line">    subType.prototype = prototype;               // 将子类的原型替换为这个原型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>ES6 class extends<br>核心：es6的继承结果和寄生组合继承相似，但是，寄生组合继承是先创建子类实例this对象，然后再对其进行加强；而es6先将父类实例对象的属性和方法，加到this上面，然后又再使用子类的构造函数修改this</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf = function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// B 的实例继承 A 的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line">// B 继承 A 的静态属性</span><br><span class="line">Object.setPrototypeOf(B, A);</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/58f94c9bb123db411953691b" target="_blank" rel="noopener">https://juejin.im/post/58f94c9bb123db411953691b</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;h4 id=&quot;继承分类&quot;&gt;&lt;a href=&quot;#继承分类&quot; class=&quot;headerlink&quot; title=&quot;继承分类&quot;&gt;&lt;/a&gt;继承分类&lt;/h4&gt;&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="web" scheme="https://xue5602.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>linux服务器上安装puppeteer</title>
    <link href="https://xue5602.github.io/2018/12/20/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85puppeteer/"/>
    <id>https://xue5602.github.io/2018/12/20/linux服务器上安装puppeteer/</id>
    <published>2018-12-20T08:38:07.000Z</published>
    <updated>2018-12-20T14:40:18.799Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g puppeteer</span><br></pre></td></tr></table></figure><p>可能的报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(node:32) UnhandledPromiseRejectionWarning: Error: Failed to launch chrome!</span><br><span class="line">/usr/local/lib/node_modules/puppeteer/.local-chromium/linux-543305/chrome-linux/chrome: error while loading shared libraries: libX11.so.6: cannot open shared object file: No such file or directory</span><br><span class="line"></span><br><span class="line">TROUBLESHOOTING: https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md</span><br><span class="line"></span><br><span class="line">    at onClose (/usr/local/lib/node_modules/puppeteer/lib/Launcher.js:246:14)</span><br><span class="line">    at Interface.helper.addEventListener (/usr/local/lib/node_modules/puppeteer/lib/Launcher.js:235:50)</span><br><span class="line">    at Interface.emit (events.js:185:15)</span><br><span class="line">    at Interface.close (readline.js:379:8)</span><br><span class="line">    at Socket.onend (readline.js:152:10)</span><br><span class="line">    at Socket.emit (events.js:185:15)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1106:12)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:114:19)</span><br><span class="line">(node:32) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)</span><br><span class="line">(node:32) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install chromium</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;p&gt;安装&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
      <category term="linux" scheme="https://xue5602.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>atob解码utf-8字符</title>
    <link href="https://xue5602.github.io/2018/12/19/atob%E8%A7%A3%E7%A0%81utf-8%E5%AD%97%E7%AC%A6/"/>
    <id>https://xue5602.github.io/2018/12/19/atob解码utf-8字符/</id>
    <published>2018-12-19T09:21:57.000Z</published>
    <updated>2018-12-19T16:15:01.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><p>使用场景：后台传来经过base64编码的字符串(含有中文), 需要在前端进行解码。</p><p>代码一：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getUserName: (str) =&gt; &#123;</span><br><span class="line">    return decodeURIComponent(atob(str))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p></p><p>bug：中文解码后，出现乱码。<br>原因：js中的atob函数(<font color="blue">拉丁字符集</font>)不支持unicode字符集。</p><p>解决：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getUserName: (str) =&gt; &#123;</span><br><span class="line">       return decodeURIComponent(escape(atob(str)));</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p></p><ul><li>使用escape对拉丁字符串进行编码,将拉丁字符集翻译成对应的十六进制符号；</li><li>使用decodeURIComponent(<font color="red">utf-8字符集</font>)解析,把十六进制符号翻译成utf-8字符集中对应的字符!</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用utf-8字符集进行base64编码</span><br><span class="line">function utoa(str) &#123;</span><br><span class="line">    return btoa(unescape(encodeURIComponent(str)));</span><br><span class="line">&#125;</span><br><span class="line">// 使用utf-8字符集解码base64字符串 </span><br><span class="line">function atou(str) &#123;</span><br><span class="line">    return decodeURIComponent(escape(atob(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;p&gt;使用场景：后台传来经过base64编码的字符串(含有中文), 需要在前端进行解码。&lt;/p&gt;&lt;p&gt;代码一：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="web" scheme="https://xue5602.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js安装之windows篇</title>
    <link href="https://xue5602.github.io/2018/12/15/node.js%E5%AE%89%E8%A3%85%E4%B9%8Bwindows%E7%AF%87/"/>
    <id>https://xue5602.github.io/2018/12/15/node.js安装之windows篇/</id>
    <published>2018-12-15T09:34:29.000Z</published>
    <updated>2019-01-10T02:12:24.491Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">官网下载windows版本的nodejs并进行安装（d:\program files\nodejs）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装完成后，win+r进入终端测试安装是否完成  node -v   npm -v</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置npm全局模块的存放路径以及缓存路径</span><br><span class="line">进入nodejs目录：分别创建node_global和node_cache两个文件夹</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自定义npm全局路径（设置成功后通过npm安转的包都会存放在node_global文件夹下面）</span><br><span class="line">npm config set prefix &quot;D:\program files\nodejs\node_global&quot;  </span><br><span class="line">npm config set cache &quot;D:\program files\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><pre><code>配置环境变量  &quot;我的电脑&quot;-&gt; &quot;属性&quot;-&gt;&quot;高级系统设置&quot;-&gt;&quot;高级&quot;-&gt;&quot;环境变量&quot;  系统环境变量下新建  NODE_PATH = D:\program files\nodejs\node_global\node_modules  由于改变了modules的默认地址，所以上面的用户变量也需要跟着改变，用户变量PATH修改为D:\program files\nodejs\node_global\  注意：  1.如果不修改用户变量的值，将会导致使用module的时候出现“xxx不是内部或外部命令，也不是可运行的程序或批处理的文件”。  2.因为配置的环境变量涉及到全局，所以配置完成后需要重启计算机。</code></pre><p>注：shutdown /r 重新启动windows服务器<br>参考文献：<a href="https://www.jianshu.com/p/03a76b2e7e00" target="_blank" rel="noopener">https://www.jianshu.com/p/03a76b2e7e00</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="node" scheme="https://xue5602.github.io/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>linux服务器上安装8.x版本node</title>
    <link href="https://xue5602.github.io/2018/12/10/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%858.x%E7%89%88%E6%9C%ACnode/"/>
    <id>https://xue5602.github.io/2018/12/10/linux服务器上安装8.x版本node/</id>
    <published>2018-12-10T07:44:50.000Z</published>
    <updated>2018-12-20T14:41:46.776Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><p>方法一：使用curl安装<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</span><br><span class="line">sudo yum -y install nodejs</span><br><span class="line">执行 node -v  检查node是否安装成功</span><br></pre></td></tr></table></figure><p></p><p>方法二：使用wget安装<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.进入usr/local目录  </span><br><span class="line"></span><br><span class="line">wget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">2.解压</span><br><span class="line">sudo tar -xvf node-v8.0.0-linux-x64.tar.xz </span><br><span class="line"></span><br><span class="line">3.重命名</span><br><span class="line">mv node-v8.0.0-linux-x64 node</span><br><span class="line"></span><br><span class="line">4.进入node/bin目录</span><br><span class="line">ls   </span><br><span class="line">./node -v</span><br><span class="line"></span><br><span class="line">5.建立软链接（可以在任何目录下执行 node 和 npm 命令）</span><br><span class="line">sudo ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /usr/local/node/bin/npm /usr/bin/npm</span><br></pre></td></tr></table></figure><p></p><p>注：<br>安装wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure><p>可能的报错<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Setting up Install Process</span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.zju.edu.cn</span><br><span class="line"> * extras: mirrors.skyshe.cn</span><br><span class="line"> * updates: mirrors.zju.edu.cn</span><br><span class="line">No package available.</span><br><span class="line">Error: Nothing to do</span><br></pre></td></tr></table></figure><p></p><p>报错解决<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><p></p><p>什么是EPEL?<br>EPEL的全称叫 Extra Packages for Enterprise Linux 。</p><p>遇到的问题:<br>node -v 查看node版本时发现node的版本为6.x</p><p>项目需求：安装7.6.0以上的node</p><p>解决过程</p><ul><li style="list-style:none"><input type="checkbox" checked> 卸载node</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. yum remove nodejs npm -y</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.手动删除残余</span><br><span class="line">进入 /usr/local/lib 删除所有 node 和 node_modules文件夹</span><br><span class="line">进入 /usr/local/include 删除所有 node 和 node_modules 文件夹</span><br><span class="line">检查 ~ 文件夹里面的&quot;local&quot; &quot;lib&quot; &quot;include&quot; 文件夹，然后删除里面的所有 &quot;node&quot; 和 &quot;node_modules&quot; 文件夹</span><br><span class="line">可以使用以下命令查找 $ find ~/ -name node $ find ~/ -name node_modules</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. 进入/usr/local/bin 删除node可执行文件  </span><br><span class="line">删除: /usr/local/bin/npm</span><br><span class="line">删除: /usr/local/share/man/man1/node.1</span><br><span class="line">删除: /usr/local/lib/dtrace/node.d</span><br><span class="line">删除: rm -rf /home/[homedir]/.npm</span><br><span class="line">删除: rm -rf /home/root/.npm</span><br></pre></td></tr></table></figure><ul><li style="list-style:none"><input type="checkbox" checked> 升级node</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.安装n</span><br><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.安装最新版</span><br><span class="line">n latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.安装指定版本</span><br><span class="line">n 8.11.3</span><br></pre></td></tr></table></figure><p>[参考文献] <a href="https://segmentfault.com/a/1190000015302680" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015302680</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;p&gt;方法一：使用curl安装&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="node" scheme="https://xue5602.github.io/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>puppeteer初探</title>
    <link href="https://xue5602.github.io/2018/12/09/puppeteer%E5%88%9D%E6%8E%A2/"/>
    <id>https://xue5602.github.io/2018/12/09/puppeteer初探/</id>
    <published>2018-12-09T04:24:02.000Z</published>
    <updated>2018-12-11T07:05:42.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><p>导语：我们日常使用的浏览器步骤为：启动浏览器、打开一个网页、进行交互。无头浏览器则是通过执行脚本来模拟真实的浏览器使用场景。</p><h3 id="headless-Chrome"><a href="#headless-Chrome" class="headerlink" title="headless Chrome"></a>headless Chrome</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Puppeteer 使用 DevTools 协议 与浏览器进行通信</span><br><span class="line">2. 对网页进行截图保存为图片或pdf</span><br><span class="line">3. 抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题)</span><br><span class="line">4. 做表单的自动提交、UI的自动化测试、模拟键盘输入等</span><br><span class="line">5. 用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题</span><br><span class="line">6. 在最新的无头浏览器环境里做测试、使用最新浏览器特性</span><br></pre></td></tr></table></figure><p>安装<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set puppeteer_download_host=https://npm.taobao.org/mirrors</span><br><span class="line">npm i puppeteer -S</span><br></pre></td></tr></table></figure><p></p><p>简单示例<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line"></span><br><span class="line">async function run() &#123;</span><br><span class="line">  const browser = await puppeteer.launch(&#123;headless:false&#125;);   </span><br><span class="line">  const page = await browser.newPage();</span><br><span class="line">  await page.goto(&apos;https://www.baidu.com&apos;);</span><br><span class="line">  await page.screenshot(&#123;path: &apos;baidu.png&apos;&#125;);</span><br><span class="line">  await page.pdf(&#123;path: &apos;baidu.pdf&apos;, format: &apos;A4&apos;&#125;);</span><br><span class="line">  browser.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure><p></p><p>page.evaluate(pageFunction, …args):向页面注入函数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  const browser = await puppeteer.launch();</span><br><span class="line">  const page = await browser.newPage();</span><br><span class="line">  await page.goto(&apos;http://www.baidu.com&apos;&apos;);</span><br><span class="line">  const dimensions = await page.evaluate(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      width: document.documentElement.clientWidth,</span><br><span class="line">      height: document.documentElement.clientHeight,</span><br><span class="line">      deviceScaleFactor: window.devicePixelRatio</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.log(&apos;Dimensions:&apos;, dimensions);</span><br><span class="line">  await browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><ul><li style="list-style:none"><input type="checkbox" checked> 参考文献</li><li><a href="https://juejin.im/post/59e5a86c51882578bf185dba" target="_blank" rel="noopener">https://juejin.im/post/59e5a86c51882578bf185dba</a></li><li><a href="https://www.jianshu.com/p/2f04f9d665ce" target="_blank" rel="noopener">https://www.jianshu.com/p/2f04f9d665ce</a></li><li><a href="http://csbun.github.io/blog/2017/09/puppeteer/" target="_blank" rel="noopener">http://csbun.github.io/blog/2017/09/puppeteer/</a></li><li><a href="https://juejin.im/entry/5a3aa0e86fb9a045076fd385" target="_blank" rel="noopener">https://juejin.im/entry/5a3aa0e86fb9a045076fd385</a></li><li><a href="https://juejin.im/post/59ca032d51882536d37f3154" target="_blank" rel="noopener">https://juejin.im/post/59ca032d51882536d37f3154</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;p&gt;导语：我们日常使用的浏览器步骤为：启动浏览器、打开一个网页、进行交互。无头浏览器则是通过执行脚本来模拟真实的浏览器使用场景。&lt;/p&gt;&lt;h3 id=&quot;head
      
    
    </summary>
    
      <category term="浏览器" scheme="https://xue5602.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="https://xue5602.github.io/2018/12/01/linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://xue5602.github.io/2018/12/01/linux命令/</id>
    <published>2018-12-01T03:28:15.000Z</published>
    <updated>2018-12-10T13:43:13.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><p>curl命令：该命令是一个利用url规则在命令行下工作的文件传输工具，支持文件的上传和下载。curl支持http、https、ftp等协议<br>语法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl（选项）（参数）</span><br></pre></td></tr></table></figure><p></p><p>系统中没有curl可以使用yum install curl安装<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl url --slient （将下载文件输出到终端，所有的下载数据写入到stdout；--slient不显示进度信息）</span><br><span class="line">curl http://man.linuxde.net/test.iso -o filename.iso --progress（-o是将下载的数据写入到文件，必须使用文件的绝对路径；--progress显示进度条）</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package...]</span><br><span class="line">options: 可选项，（-h帮助，-y当安装过程提示全部选择yes，-q不显示安装过程）</span><br><span class="line">yum -y install nodejs</span><br></pre></td></tr></table></figure><p>常用命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. ls 列出文件或文件目录</span><br><span class="line">2. cd    切换目录</span><br><span class="line">3. mkdir       创建文件夹</span><br><span class="line">4. unzip ***.zip     解压 .zip文件到当前目录（若提示找不到命令unzip，需要执行yum install -y unzip zip）</span><br><span class="line">5. tar -xvf  ***.tar   解压 .tar文件到当前目录</span><br><span class="line">6. tar xvJf   ***.tar.xz   解压 .tar.xz文件到当前目录</span><br><span class="line">7. rm -r    文件夹名称       -f  文件夹名称    删除文件夹 </span><br><span class="line">8. rm   文件名      删除文件</span><br><span class="line">9. cat  文件名      查看文件内容</span><br><span class="line">10. vi 文件名      进入文件,按下 i 键 ，出现 -- INSERT-- 就可以编辑了,按esc之后输入:wq, 保存并退出编辑模式 </span><br><span class="line">11. lsof -i  tcp:端口号  查看端口号 被哪个进程占用 （yum install lsof）  kill -9 端口号   杀掉进程</span><br><span class="line">12. pwd 查看当前文件的目录</span><br><span class="line">13. lsb_release -a  获取linux操作系统</span><br><span class="line">14. df -h  磁盘空间</span><br><span class="line">15. echo $LANG    查看linux下当前使用语言命令</span><br><span class="line">16. sudo -i 切换root用户</span><br><span class="line">17. mv 文件名 移动目的地文件名 （移动文件、重命名文件）</span><br><span class="line">18. yum remove nodejs （卸载node）</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;p&gt;curl命令：该命令是一个利用url规则在命令行下工作的文件传输工具，支持文件的上传和下载。curl支持http、https、ftp等协议&lt;br&gt;语法&lt;br
      
    
    </summary>
    
      <category term="linux" scheme="https://xue5602.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客</title>
    <link href="https://xue5602.github.io/2018/07/23/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xue5602.github.io/2018/07/23/Hexo搭建个人博客/</id>
    <published>2018-07-22T22:10:48.000Z</published>
    <updated>2018-12-20T14:41:04.678Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --><p>1 准备工作<br>. 有一个github账号<br>. 安装node.js<br>. 安装git</p><p>2 搭建github博客<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新建一个名为 你的用户名.github.io 的仓库。</span><br></pre></td></tr></table></figure><p></p><p>3 配置SSH key<br>配置ssh key的原因：提交代码时需要将本地和远程仓库进行连接，直接使用用户名和密码不太安全。所以需要用ssh key解决本地和服务器连接的问题。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ～/.ssh    检测本地已经存在的ssh密钥</span><br></pre></td></tr></table></figure><p></p><p>如果提示：不存在该文件夹，则说明是第一次使用github<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C   “邮件地址”</span><br></pre></td></tr></table></figure><p></p><p>（连续三次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开github主页，进入setting-&gt;SSH and GPG key -&gt;new ssh key）<br>此时，还需要配置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config —-global  user.name “昵称”</span><br><span class="line">git config —-global  user.email  “邮箱”</span><br></pre></td></tr></table></figure><p></p><p>4 使用hexo编写个人博客<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装： npm install -g hexo</span><br><span class="line">初始化： npm init blog</span><br><span class="line">生成静态文件： hexo g</span><br><span class="line">启动服务器： hexo s</span><br><span class="line">部署到github： hexo d</span><br><span class="line">使用hexo d 的前提是安装了一个插件： npm install hexo-deployer-git –-save</span><br></pre></td></tr></table></figure><p></p><p>5 hexo 常见的口令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new “” 新建文章</span><br><span class="line">hexo new page “” 新建页面</span><br><span class="line">hexo generate 生成静态文件到public目录</span><br><span class="line">hexo deploy 部署到github</span><br><span class="line">hexo version 查看hexo的版本号</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 08 2019 16:52:58 GMT+0800 (CST) --&gt;&lt;p&gt;1 准备工作&lt;br&gt;. 有一个github账号&lt;br&gt;. 安装node.js&lt;br&gt;. 安装git&lt;/p&gt;&lt;p&gt;2 搭建github博客&lt;br&gt;&lt;/p&gt;&lt;f
      
    
    </summary>
    
      <category term="hexo" scheme="https://xue5602.github.io/categories/hexo/"/>
    
    
  </entry>
  
</feed>
