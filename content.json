{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"tina","url":"https://xue5602.github.io"},"pages":[],"posts":[{"title":"css隐藏滚动条","slug":"css隐藏滚动条","date":"2019-01-26T10:29:38.000Z","updated":"2019-01-31T09:09:22.544Z","comments":true,"path":"2019/01/26/css隐藏滚动条/","link":"","permalink":"https://xue5602.github.io/2019/01/26/css隐藏滚动条/","excerpt":"","text":"导语： 在前端开发中，我们经常会遇到这样的情况，为了让页面看起来更加美观，需要将滚动条进行隐藏。下面介绍几种常用的方法：方法1、 使用三个容器将内容包裹起来，并通过css样式将滚动条隐藏1234567&lt;div class=&quot;outer-container&quot;&gt; &lt;div class=&quot;inner-container&quot;&gt; &lt;div class=&quot;content&quot;&gt; ...... &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;12345678910111213.outer-container &#123; height: 100%;&#125;.inner-container &#123; height: calc(100% - 40px); overflow-x: hidden; overflow-y: scroll;&#125;.inner-container::-webkit-scrollbar &#123; display: none;&#125;注意::-webkit-scrollbar 仅仅支持webkit的浏览器，如Chrome，Safari等方法2、外层容器的宽度设置为窗口宽度 + 10px1234567891011.outer-container &#123; width: calc(100vw + 10px); // 隐藏滚动条&#125;.inner-container &#123; height: calc(100% - 40px); overflow-x: hidden; overflow-y: scroll;&#125;.inner-container::-webkit-scrollbar &#123; display: none;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://xue5602.github.io/categories/web/"}],"tags":[]},{"title":"angular-translate进行项目国际化","slug":"angular-translate进行项目国际化","date":"2019-01-19T03:17:23.000Z","updated":"2019-01-31T09:19:29.347Z","comments":true,"path":"2019/01/19/angular-translate进行项目国际化/","link":"","permalink":"https://xue5602.github.io/2019/01/19/angular-translate进行项目国际化/","excerpt":"","text":"安装插件12bower install angular-translate bower install angular-translate-loader-static-files直接引入（二选一）12&lt;script src=&quot;editor-app/libs/angular-translate_2.4.2/angular-translate.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;editor-app/libs/angular-translate-loader-static-files/angular-translate-loader-static-files.js&quot;&gt;&lt;/script&gt;注： angular-translate-loader-static-files.min.js用来读取本地多语言文件。添加翻译文本1在项目中建立/i18/文件夹，然后在该文件夹中添加对应的json文件（en-us.json/ch-cn.json）4.注入依赖12345678910111213141516171819202122232425262728293031var myApp = angular.module(&apos;myApp&apos;, [ &apos;pascalprecht.translate&apos;]);myApp.config([&apos;$translateProvider&apos;, function ( $translateProvider) &#123; // 从cookie里获取 lang function getCookie(name)&#123; var strcookie = document.cookie;//获取cookie字符串 var arrcookie = strcookie.split(&quot;; &quot;);//分割 for ( var i = 0; i &lt; arrcookie.length; i++) &#123; var arr = arrcookie[i].split(&quot;=&quot;); if (arr[0] == name)&#123; return arr[1]; &#125; &#125; return &quot;&quot;; &#125; var lang = getCookie(&apos;language&apos;); $translateProvider.useStaticFilesLoader(&#123; prefix: &apos;/i18n/&apos;, suffix: &apos;.json&apos; &#125;); // 加载本地多语言配置文件 $translateProvider.useStaticFilesLoader(&#123; prefix: &apos;./i18n/&apos;, suffix: &apos;.json&apos; &#125;); $translateProvider.preferredLanguage(lang);创建过滤器做html内容国际化1234567.filter(&apos;translate&apos;, [&apos;$translate&apos;, function ($translate) &#123; return function (key) &#123; if (key) &#123; return $translate.instant(key); &#125; &#125; &#125;])123456&lt;div class=&quot;Or-button&quot; id=&quot;delete-button&quot; title=&quot;&#123;&#123;&apos;BUTTON.DELETE.TOOLTIP&apos; | translate&#125;&#125;&quot; ng-click=&quot;deleteTooltip()&quot;/&gt;javascript 脚本中使用国际化1$translate.instant(&quot;TOOLBAR.DESIGN.MODULE&quot;)","categories":[{"name":"web","slug":"web","permalink":"https://xue5602.github.io/categories/web/"}],"tags":[]},{"title":"原型链","slug":"原型链","date":"2019-01-12T07:24:05.000Z","updated":"2019-01-31T09:07:36.295Z","comments":true,"path":"2019/01/12/原型链/","link":"","permalink":"https://xue5602.github.io/2019/01/12/原型链/","excerpt":"","text":"构造函数a. 构造函数的首字母大写 (习惯)b. 内部使用this对象，指向即将生成的实例对象c. 使用new来生成实例对象new 一个对象1234567function Person()&#123; this.p = “I’m in constructed object”; this.alertP = function()&#123; alert(this.p); &#125;&#125;var o2 = new Person();new操作符来调用一个函数，发生了什么？1234var obj = &#123;&#125;obj._ptoto_ = Person.prototype;Person.call(obj);return objprototype属性 每一个构造函数都有一个属性：prototype，其作用是为一个特定类申明通用的变量和函数。在函数内定义的变量和函数如果不对外提供接口，外部将无法访问。12345function Obj()&#123; var a=0; //私有变量 var fn=function()&#123; //私有函数 &#125; &#125;123var o=new Obj();console.log(o.a); //undefinedconsole.log(o.fn); //undefined静态变量、函数当定义一个函数后，通过.添加的属性和函数，通过对象本身是可以访问，但实例却不可以访问，这样的变量和函数称为静态变量和静态函数。12345678910111213141516function Obj()&#123;&#125;Obj.a=0; //静态变量Obj.fn=function()&#123; //静态函数&#125;console.log(Obj.a); //0console.log(typeof Obj.fn); //functionvar o=new Obj();console.log(o.a); //undefinedconsole.log(typeof o.fn); //undefined实例变量和函数12345678910111213function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例方法 &#125;&#125;console.log(typeof Obj.a); //undefinedconsole.log(typeof Obj.fn); //undefinedvar o=new Obj();console.log(typeof o.a); //objectconsole.log(typeof o.fn); //function一个函数要作为一个真正意义上的构造函数，必须满足下列条件：12在函数内部对新对象（this）的属性进行设置，通常是添加属性和方法。构造函数可以包含返回语句（不推荐），但返回值必须是this，或者其它非对象类型的值。原型和原型链所有引用类型（函数，数组，对象）都拥有proto属性（隐式原型）所有函数拥有prototype属性（显式原型）（仅限函数）原型对象：拥有prototype属性的对象，在定义函数时就被创建1234567891011121314151617//创建构造函数function Word(words)&#123; this.words = words;&#125;Word.prototype = &#123; alert()&#123; alert(this.words); &#125;&#125;//创建实例var w = new Word(&quot;hello world&quot;);w.print = function()&#123; console.log(this.words); console.log(this); //Person对象&#125;w.print(); //hello worldw.alert(); //hello world实例w的隐式原型指向它构造函数的显式原型，指向的意思是恒等于1w.__proto__ === Word.prototype当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的proto属性中调用查找，也就是它构造函数的prototype中调用查找。12345678Function.prototype.a = &quot;a&quot;;Object.prototype.b = &quot;b&quot;;function Person()&#123;&#125;console.log(Person); //function Person()let p = new Person();console.log(p); //Person &#123;&#125; 对象console.log(p.a); //undefinedconsole.log(p.b); //b1234567function Function()&#123;&#125;console.log(Function); // Function()console.log(Function.prototype.constructor); //Function()console.log(Function.prototype.__proto__); //Object.prototypeconsole.log(Function.prototype.__proto__.__proto__); //NULLconsole.log(Function.prototype.__proto__.constructor); //Object()console.log(Function.prototype.__proto__ === Object.prototype); //true","categories":[{"name":"web","slug":"web","permalink":"https://xue5602.github.io/categories/web/"}],"tags":[]},{"title":"javascript继承","slug":"javascript继承","date":"2019-01-05T02:15:50.000Z","updated":"2019-01-10T02:17:24.631Z","comments":true,"path":"2019/01/05/javascript继承/","link":"","permalink":"https://xue5602.github.io/2019/01/05/javascript继承/","excerpt":"","text":"继承分类基于原型链继承（把子类的prototype设置为父类的实例）12345678// 父类function Person() &#123;&#125;// 子类function Student()&#123;&#125;// 继承Student.prototype = new Person()原型继承的缺点：如果属性是引用类型的话，会共享引用类型(引用属性会被所有实例共享)12345678910// 父类function Person() &#123; this.hobbies = [&apos;music&apos;,&apos;reading&apos;]&#125;// 子类function Student()&#123;&#125;// 继承Student.prototype = new Person()1234567var stu1 = new Student()var stu2 = new Student()stu1.hobbies.push(&apos;basketball&apos;)console.log(stu1.hobbies) // music,reading,basketballconsole.log(stu2.hobbies) // music,reading,basketball构造函数继承（在子类中执行父类的构造函数）123456789// 父类function Person() &#123; this.hobbies = [&apos;muisc&apos;, &apos;writing&apos;, &apos;reading&apos;]&#125;// 子类function Student()&#123; Person.call(this) // 改动的代码&#125;12345var stu1 = new Student()var stu2 = new Student()stud1.hobbies.push(&apos;swimming&apos;)console.log(stud1.hobbies) // [&apos;muisc&apos;, &apos;writing&apos;, &apos;reading&apos;, &apos;swimming&apos;]console.log(stud2.hobbies) // [&apos;muisc&apos;, &apos;writing&apos;, &apos;reading&apos;]构造函数解决了引用类型被共享的问题，但是同时也导致了一个新的问题，每实例化一个子类，就复制了一次父类。继承方式继承核心代码优缺点原型链继承Student.prototype = new Person()实例的引用类型共享构造函数继承在子类(Student)里执行 Person.call(this)实例的引用类型不共享组合继承（普通函数使用构造函数继承，函数使用原型链继承）1234567891011121314// 父类function Person() &#123; this.hobbies = [&apos;music&apos;,&apos;reading&apos;]&#125;// 父类函数Person.prototype.say = function() &#123;console.log(&apos;I am a person&apos;)&#125;// 子类function Student()&#123; Person.call(this) // 构造函数继承(继承属性) （第二次调用）&#125;// 继承Student.prototype = new Person() // 原型链继承(继承方法) (第一次调用)123456789// 实例化var stu1 = new Student()var stu2 = new Student()stu1.hobbies.push(&apos;basketball&apos;)console.log(stu1.hobbies) // music,reading,basketballconsole.log(stu2.hobbies) // music,readingconsole.log(stu1.say == stu2.say) // true优点：父类的方法可以被复用父类的引用属性不会被共享子类构建实例时可以向父类传递参数缺点：调用了两次父类的构造函数，第二次调用覆盖了第一次调用的同名参数。这种被覆盖的情况造成了性能上的浪费。寄生式继承核心：使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力123456789101112131415function createAnother(original)&#123; var clone=object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone; //返回这个对象&#125;var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot;寄生组合继承123456789101112131415161718192021222324function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125;function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;ES6 class extends核心：es6的继承结果和寄生组合继承相似，但是，寄生组合继承是先创建子类实例this对象，然后再对其进行加强；而es6先将父类实例对象的属性和方法，加到this上面，然后又再使用子类的构造函数修改this12345678910111213141516class A &#123;&#125;class B &#123;&#125;Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);https://juejin.im/post/58f94c9bb123db411953691b","categories":[{"name":"web","slug":"web","permalink":"https://xue5602.github.io/categories/web/"}],"tags":[]},{"title":"linux服务器上安装puppeteer","slug":"linux服务器上安装puppeteer","date":"2018-12-20T08:38:07.000Z","updated":"2018-12-20T14:40:18.799Z","comments":true,"path":"2018/12/20/linux服务器上安装puppeteer/","link":"","permalink":"https://xue5602.github.io/2018/12/20/linux服务器上安装puppeteer/","excerpt":"","text":"安装1cnpm install -g puppeteer可能的报错123456789101112131415(node:32) UnhandledPromiseRejectionWarning: Error: Failed to launch chrome!/usr/local/lib/node_modules/puppeteer/.local-chromium/linux-543305/chrome-linux/chrome: error while loading shared libraries: libX11.so.6: cannot open shared object file: No such file or directoryTROUBLESHOOTING: https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md at onClose (/usr/local/lib/node_modules/puppeteer/lib/Launcher.js:246:14) at Interface.helper.addEventListener (/usr/local/lib/node_modules/puppeteer/lib/Launcher.js:235:50) at Interface.emit (events.js:185:15) at Interface.close (readline.js:379:8) at Socket.onend (readline.js:152:10) at Socket.emit (events.js:185:15) at endReadableNT (_stream_readable.js:1106:12) at process._tickCallback (internal/process/next_tick.js:114:19)(node:32) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)(node:32) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.解决1yum install chromium","categories":[{"name":"linux","slug":"linux","permalink":"https://xue5602.github.io/categories/linux/"}],"tags":[]},{"title":"atob解码utf-8字符","slug":"atob解码utf-8字符","date":"2018-12-19T09:21:57.000Z","updated":"2018-12-19T16:15:01.506Z","comments":true,"path":"2018/12/19/atob解码utf-8字符/","link":"","permalink":"https://xue5602.github.io/2018/12/19/atob解码utf-8字符/","excerpt":"","text":"使用场景：后台传来经过base64编码的字符串(含有中文), 需要在前端进行解码。代码一：123getUserName: (str) =&gt; &#123; return decodeURIComponent(atob(str))&#125;,bug：中文解码后，出现乱码。原因：js中的atob函数(拉丁字符集)不支持unicode字符集。解决：123getUserName: (str) =&gt; &#123; return decodeURIComponent(escape(atob(str))); &#125;,使用escape对拉丁字符串进行编码,将拉丁字符集翻译成对应的十六进制符号；使用decodeURIComponent(utf-8字符集)解析,把十六进制符号翻译成utf-8字符集中对应的字符!12345678// 使用utf-8字符集进行base64编码function utoa(str) &#123; return btoa(unescape(encodeURIComponent(str)));&#125;// 使用utf-8字符集解码base64字符串 function atou(str) &#123; return decodeURIComponent(escape(atob(str)));&#125;","categories":[{"name":"web","slug":"web","permalink":"https://xue5602.github.io/categories/web/"}],"tags":[]},{"title":"node.js安装之windows篇","slug":"node.js安装之windows篇","date":"2018-12-15T09:34:29.000Z","updated":"2019-01-10T02:12:24.491Z","comments":true,"path":"2018/12/15/node.js安装之windows篇/","link":"","permalink":"https://xue5602.github.io/2018/12/15/node.js安装之windows篇/","excerpt":"","text":"1官网下载windows版本的nodejs并进行安装（d:\\program files\\nodejs）1安装完成后，win+r进入终端测试安装是否完成 node -v npm -v12配置npm全局模块的存放路径以及缓存路径进入nodejs目录：分别创建node_global和node_cache两个文件夹123自定义npm全局路径（设置成功后通过npm安转的包都会存放在node_global文件夹下面）npm config set prefix &quot;D:\\program files\\nodejs\\node_global&quot; npm config set cache &quot;D:\\program files\\nodejs\\node_cache&quot;配置环境变量 &quot;我的电脑&quot;-&gt; &quot;属性&quot;-&gt;&quot;高级系统设置&quot;-&gt;&quot;高级&quot;-&gt;&quot;环境变量&quot; 系统环境变量下新建 NODE_PATH = D:\\program files\\nodejs\\node_global\\node_modules 由于改变了modules的默认地址，所以上面的用户变量也需要跟着改变，用户变量PATH修改为D:\\program files\\nodejs\\node_global\\ 注意： 1.如果不修改用户变量的值，将会导致使用module的时候出现“xxx不是内部或外部命令，也不是可运行的程序或批处理的文件”。 2.因为配置的环境变量涉及到全局，所以配置完成后需要重启计算机。 注：shutdown /r 重新启动windows服务器参考文献：https://www.jianshu.com/p/03a76b2e7e00","categories":[{"name":"node","slug":"node","permalink":"https://xue5602.github.io/categories/node/"}],"tags":[]},{"title":"linux服务器上安装8.x版本node","slug":"linux服务器上安装8.x版本node","date":"2018-12-10T07:44:50.000Z","updated":"2018-12-20T14:41:46.776Z","comments":true,"path":"2018/12/10/linux服务器上安装8.x版本node/","link":"","permalink":"https://xue5602.github.io/2018/12/10/linux服务器上安装8.x版本node/","excerpt":"","text":"方法一：使用curl安装123curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -sudo yum -y install nodejs执行 node -v 检查node是否安装成功方法二：使用wget安装12345678910111213141516171.进入usr/local目录 wget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz2.解压sudo tar -xvf node-v8.0.0-linux-x64.tar.xz 3.重命名mv node-v8.0.0-linux-x64 node4.进入node/bin目录ls ./node -v5.建立软链接（可以在任何目录下执行 node 和 npm 命令）sudo ln -s /usr/local/node/bin/node /usr/bin/nodesudo ln -s /usr/local/node/bin/npm /usr/bin/npm注：安装wget1yum -y install wget可能的报错12345678Loaded plugins: fastestmirror, refresh-packagekit, securitySetting up Install ProcessDetermining fastest mirrors * base: mirrors.zju.edu.cn * extras: mirrors.skyshe.cn * updates: mirrors.zju.edu.cnNo package available.Error: Nothing to do报错解决1yum install -y epel-release什么是EPEL?EPEL的全称叫 Extra Packages for Enterprise Linux 。遇到的问题:node -v 查看node版本时发现node的版本为6.x项目需求：安装7.6.0以上的node解决过程 卸载node11. yum remove nodejs npm -y123452.手动删除残余进入 /usr/local/lib 删除所有 node 和 node_modules文件夹进入 /usr/local/include 删除所有 node 和 node_modules 文件夹检查 ~ 文件夹里面的&quot;local&quot; &quot;lib&quot; &quot;include&quot; 文件夹，然后删除里面的所有 &quot;node&quot; 和 &quot;node_modules&quot; 文件夹可以使用以下命令查找 $ find ~/ -name node $ find ~/ -name node_modules1234563. 进入/usr/local/bin 删除node可执行文件 删除: /usr/local/bin/npm删除: /usr/local/share/man/man1/node.1删除: /usr/local/lib/dtrace/node.d删除: rm -rf /home/[homedir]/.npm删除: rm -rf /home/root/.npm 升级node121.安装nnpm install -g n122.安装最新版n latest123.安装指定版本n 8.11.3[参考文献] https://segmentfault.com/a/1190000015302680","categories":[{"name":"node","slug":"node","permalink":"https://xue5602.github.io/categories/node/"}],"tags":[]},{"title":"puppeteer初探","slug":"puppeteer初探","date":"2018-12-09T04:24:02.000Z","updated":"2018-12-11T07:05:42.229Z","comments":true,"path":"2018/12/09/puppeteer初探/","link":"","permalink":"https://xue5602.github.io/2018/12/09/puppeteer初探/","excerpt":"","text":"导语：我们日常使用的浏览器步骤为：启动浏览器、打开一个网页、进行交互。无头浏览器则是通过执行脚本来模拟真实的浏览器使用场景。headless Chrome1234561. Puppeteer 使用 DevTools 协议 与浏览器进行通信2. 对网页进行截图保存为图片或pdf3. 抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题)4. 做表单的自动提交、UI的自动化测试、模拟键盘输入等5. 用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题6. 在最新的无头浏览器环境里做测试、使用最新浏览器特性安装12npm config set puppeteer_download_host=https://npm.taobao.org/mirrorsnpm i puppeteer -S简单示例123456789101112const puppeteer = require(&apos;puppeteer&apos;);async function run() &#123; const browser = await puppeteer.launch(&#123;headless:false&#125;); const page = await browser.newPage(); await page.goto(&apos;https://www.baidu.com&apos;); await page.screenshot(&#123;path: &apos;baidu.png&apos;&#125;); await page.pdf(&#123;path: &apos;baidu.pdf&apos;, format: &apos;A4&apos;&#125;); browser.close();&#125;run();page.evaluate(pageFunction, …args):向页面注入函数12345678910111213141516const puppeteer = require(&apos;puppeteer&apos;);(async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&apos;http://www.baidu.com&apos;&apos;); const dimensions = await page.evaluate(() =&gt; &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight, deviceScaleFactor: window.devicePixelRatio &#125;; &#125;); console.log(&apos;Dimensions:&apos;, dimensions); await browser.close();&#125;)(); 参考文献https://juejin.im/post/59e5a86c51882578bf185dbahttps://www.jianshu.com/p/2f04f9d665cehttp://csbun.github.io/blog/2017/09/puppeteer/https://juejin.im/entry/5a3aa0e86fb9a045076fd385https://juejin.im/post/59ca032d51882536d37f3154","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://xue5602.github.io/categories/浏览器/"}],"tags":[]},{"title":"linux命令","slug":"linux命令","date":"2018-12-01T03:28:15.000Z","updated":"2018-12-10T13:43:13.640Z","comments":true,"path":"2018/12/01/linux命令/","link":"","permalink":"https://xue5602.github.io/2018/12/01/linux命令/","excerpt":"","text":"curl命令：该命令是一个利用url规则在命令行下工作的文件传输工具，支持文件的上传和下载。curl支持http、https、ftp等协议语法1curl（选项）（参数）系统中没有curl可以使用yum install curl安装12curl url --slient （将下载文件输出到终端，所有的下载数据写入到stdout；--slient不显示进度信息）curl http://man.linuxde.net/test.iso -o filename.iso --progress（-o是将下载的数据写入到文件，必须使用文件的绝对路径；--progress显示进度条）123yum [options] [command] [package...]options: 可选项，（-h帮助，-y当安装过程提示全部选择yes，-q不显示安装过程）yum -y install nodejs常用命令1234567891011121314151617181. ls 列出文件或文件目录2. cd 切换目录3. mkdir 创建文件夹4. unzip ***.zip 解压 .zip文件到当前目录（若提示找不到命令unzip，需要执行yum install -y unzip zip）5. tar -xvf ***.tar 解压 .tar文件到当前目录6. tar xvJf ***.tar.xz 解压 .tar.xz文件到当前目录7. rm -r 文件夹名称 -f 文件夹名称 删除文件夹 8. rm 文件名 删除文件9. cat 文件名 查看文件内容10. vi 文件名 进入文件,按下 i 键 ，出现 -- INSERT-- 就可以编辑了,按esc之后输入:wq, 保存并退出编辑模式 11. lsof -i tcp:端口号 查看端口号 被哪个进程占用 （yum install lsof） kill -9 端口号 杀掉进程12. pwd 查看当前文件的目录13. lsb_release -a 获取linux操作系统14. df -h 磁盘空间15. echo $LANG 查看linux下当前使用语言命令16. sudo -i 切换root用户17. mv 文件名 移动目的地文件名 （移动文件、重命名文件）18. yum remove nodejs （卸载node）","categories":[{"name":"linux","slug":"linux","permalink":"https://xue5602.github.io/categories/linux/"}],"tags":[]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2018-07-22T22:10:48.000Z","updated":"2018-12-20T14:41:04.678Z","comments":true,"path":"2018/07/23/Hexo搭建个人博客/","link":"","permalink":"https://xue5602.github.io/2018/07/23/Hexo搭建个人博客/","excerpt":"","text":"1 准备工作. 有一个github账号. 安装node.js. 安装git2 搭建github博客1新建一个名为 你的用户名.github.io 的仓库。3 配置SSH key配置ssh key的原因：提交代码时需要将本地和远程仓库进行连接，直接使用用户名和密码不太安全。所以需要用ssh key解决本地和服务器连接的问题。1cd ～/.ssh 检测本地已经存在的ssh密钥如果提示：不存在该文件夹，则说明是第一次使用github1ssh-keygen -t rsa -C “邮件地址”（连续三次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开github主页，进入setting-&gt;SSH and GPG key -&gt;new ssh key）此时，还需要配置：12git config —-global user.name “昵称”git config —-global user.email “邮箱”4 使用hexo编写个人博客123456安装： npm install -g hexo初始化： npm init blog生成静态文件： hexo g启动服务器： hexo s部署到github： hexo d使用hexo d 的前提是安装了一个插件： npm install hexo-deployer-git –-save5 hexo 常见的口令12345hexo new “” 新建文章hexo new page “” 新建页面hexo generate 生成静态文件到public目录hexo deploy 部署到githubhexo version 查看hexo的版本号","categories":[{"name":"hexo","slug":"hexo","permalink":"https://xue5602.github.io/categories/hexo/"}],"tags":[]},{"title":"git flow","slug":"如何正确使用git flow","date":"2018-02-02T08:10:48.000Z","updated":"2019-02-02T09:29:27.111Z","comments":true,"path":"2018/02/02/如何正确使用git flow/","link":"","permalink":"https://xue5602.github.io/2018/02/02/如何正确使用git flow/","excerpt":"","text":"在开发一个项目的时候，总是会遇到版本回退和版本客制化的问题，糟糕的分支管理会使整个开发过程痛苦不堪。版本管理的挑战：如何开发一个Feature分支，又不影响其他的Feature分支？分支多了如何管理，时间就了每个分支是干什么的？哪些分支已经合并并回了主干？如何进行Release分支的管理？开始一个Release的时候如何冻结Feature，如何在Prepare Release 的时候，开发人员可以继续新功能的开发？线上代码除bug了，如何快速修复？而且修复的代码包含到开发人员的分支以及下一个Release？下面介绍一种常见的工作流程 git flowgit flow 的特色在于为不同的分支分配明确的角色，并定义了使用场景和用法。git flow 常用的分支Master 分支这个分支显示的是最近发布到生产环境的代码，最近发布的Release, 该分支只能从其他分支合并代码，不能在这个分支直接修改代码Develop 分支这个分支是我们的主开发分支，包含所有发布到一下个Release代码Feature 分支这个分支主要用来开发一个新的功能，一旦开发完成，我们会合并到Develop分支进行下一个ReleaseRelease 分支当需要发布一个新的Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，将其合并到Master和Develop分支Hotfix 分支当发现产线上出来一个bug后，我们需要创建一个Hotfix分支完成bug修复，测试完成后，将该分支合并到Master和Develop分支，所以Hotfix的改动会进入下一个Releasegit flow 操作实践第一步： 创建一个develop分支，并把它推到服务器12git branch developgit push -u origin developdevelop 分支将包含项目的所有历史。开发者可以clone中央仓库，并为develop分支创建一个追踪分支。12git clone ssh://......git checkout -b develop origin/develop第二步： 创建Feature分支12git checkout -b Featurename developgit push -u origin Featurename注意： Feature 的父分支应该选择develop第三步： Feature分支的功能开发完成后(edit 、state、commit)，将其合并到develop分支1234git pull origin develop //确保develop分支拥有最新代码git checkout developgit merge Featurenamegit push注意：新开发的功能代码永远不能直接合并到master分支。第四步：创建Release分支，做产品发布准备12git checkout -b release developgit push -u origin release这个分支专门用于发布前准备，包括一些清理工具、全面测试、文档的更新及准备工作。第五步：测试通过后，就可以将Release分支上的内容合并到master和develop分支上。123456git checkout mastergit merge releasegit pushgit checkout developgit merge releasegit push注意： Release保持最新版本的代码，该分支扮演着开发和生产之间的一个缓冲。无论什么时候把一些东西合并到master分支，都需要打一个tag12git tag -a v1.0.0 -m &quot;版本v1.0.0&quot; mastergit push --tags第六步： 当产品线出现bug后1git checkout -b hotfix master第七步：完成bug修复后，并通过测试，将hotfix分支上的内容合并到master/develop1234567git checkout mastergit merge hotfixgit pushgit checkout developgit merge hotfixgit pushgit branch - d hotfix第八步： 基于master分支，打tag12git tag -a v1.0.0/fix mastergit push --tagsgit flow 工具安装1brew install git-flow初始化1git flow init这个命令会进行一些默认的配置，自动创建master、develop、feature、release、hotfix分支。当进行新功能开发的时候，可以1git flow feature start Featurename完成开发后1git flow feature finish Featurename该命令会将feature/Featurename 合并到develop分支，并删除feature分支。当功能点都完成后，基于develop分支创建一个release分支12git flow release start v1.0.0git flow release finish v1.0.0注：当完成（finish)一个发布分支时，它会把release分支上的内容合并到master分支，同时合并回develop分支，打tag。之后我们只需要把master和tag都推到远程仓库就行。当产线出现bug，需要紧急修复时。1git flow hotfix start v1.0.0完成bug修复后1git flow hotfix finish v1.0.0注：当完成（finish)一个修复分支时，它会把hotfix分支上的内容合并到master分支，同时合并回develop分支。参考：https://www.cnblogs.com/cnblogsfans/p/5075073.html","categories":[{"name":"hexo","slug":"hexo","permalink":"https://xue5602.github.io/categories/hexo/"}],"tags":[]},{"title":"git 常用命令","slug":"git 常用命令","date":"2018-02-02T05:10:24.000Z","updated":"2019-02-02T09:29:54.089Z","comments":true,"path":"2018/02/02/git 常用命令/","link":"","permalink":"https://xue5602.github.io/2018/02/02/git 常用命令/","excerpt":"","text":"12345678910111. git branch -a 查看远程分支2. git push origin --delete &lt;branchName&gt; 删除远程分支3. git push origin :&lt;branchName&gt; 删除远程分支4. git push origin --delete tag &lt;tagname&gt; 删除远程tag5. git push origin :refs/tags/&lt;tagname&gt; 删除远程tag6. git fetch -p 删除没有与远程分支对应的本地分支7. 重命名远程分支 git push --delete origin branchname git branch -m branchname newname //重命名本地分支 git push origin newname8. git fetch origin tag &lt;tagname&gt; 获取远程taggit 撤销&amp;回滚操作应用场景1、把不想要的代码commit到本地仓库，但是还没有push操作；2、push上去的代码有问题，需要还原上一次提交场景1 撤销修改123git statusgit reset HEAD fileNamegit checkout fileName场景2 回滚 （首先确保当前工作区是干净的，并且和远程分支代码一致 ）撤销指定文件到指定版本12git log &lt;filename&gt;git checkout &lt;commitID&gt; &lt;filename&gt;删除最后一次提交12git revert HEADgit push origin develop回滚某次提交12git log --oneline -n5git rebase -i &quot;commit id&quot;^git 解决冲突git push 时产生冲突12git pull git push //git 自动合并冲突如果在git pull 时就存在冲突123456789101112131415方法一 丢弃本地修改，采用远程文件覆盖本地文件 git checkout [文件路径] 方法二 手动解决冲突，找到冲突文件中下列标示&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和=======中间的是你自己的代码， ======= 和&gt;&gt;&gt;&gt;&gt;&gt;&gt;中间的是其他人修改的代码。确保自己要保留的代码，并删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标示方法三 暂存本地修改 git stash //将本地修改暂存到工作区 git pull git stash pop //从栈中将本地修改的代码提取出来git stash 详解git stash 可以暂存当前正在进行的工作， 比如想pull最新代码，又不想新加commit；还有一种情况就是，为了fix一个紧急的bug，需要回到上一个commit，","categories":[{"name":"hexo","slug":"hexo","permalink":"https://xue5602.github.io/categories/hexo/"}],"tags":[]}]}